//Crossword.java

public class Crossword implements WordPuzzleInterface {
    

    private StringBuilder rowStr[];
	private StringBuilder colStr[];
    private char[] letters = {'e', 't', 'a', 'o', 'i', 'n', 's', 'h', 'r', 'd', 'l', 'c', 'u', 'm', 'w', 'f', 'g', 'y', 'p', 'b', 'v', 'k', 'j', 'x', 'q', 'z'};
    private int[] rowLastMin;
    private int[] colLastMin;
    int boardLen;

    /*
     * Fill out a word puzzle defined by an empty board. 
     * 
     *  @param board is a 2-d array representing the empty board to be filled
     *  The characters in the empty board can be:
     *    '+': any letter can go here
     *    '-': no letter is allowed to go here
     *    a letter: this letter has to remain as-is at the same position in the filled puzzle
     *    a value between '1' and '9': any letter can go here and the provided value is an upper bound on the number 
     *                                  of times the letter can appear in the filled board. If a letter has multiple 
     *                                  upper bounds, the largest bound is the effective one.
     *  @param dictionary is the dictinary to be used for filling out the puzzle. Check DictInterface for
     *                    more details on the operations provided by the dictionary
     *  @return a 2-d array representing the filled out puzzle or null if the puzzle has no solution
     */

    public char[][] fillPuzzle(char[][] board, DictInterface dictionary) {

        rowStr = new StringBuilder[board.length];
        colStr = new StringBuilder[board.length];

        for(int i=0; i<board.length; i++) {
            rowStr[i] = new StringBuilder();
            colStr[i] = new StringBuilder();
        }

        boardLen = board.length;

        //Determine where the - are
        rowLastMin = new int[boardLen];
        colLastMin = new int[boardLen];
        for(int i=0; i<boardLen; i++) {
            rowLastMin[i] = -1;
            colLastMin[i] = -1; 
        }

        for(int i=0; i<boardLen; i++) {
            for(int j=0; j<boardLen; j++) {
                if(board[i][j]=='-') {
                    rowLastMin[i] = j;
                    colLastMin[j] = i;
                }
            }
        }

        //Printing out board (used for debugging)
        /*for(int i=0; i<boardLen; i++) {
                for(int j=0; j<boardLen; j++) {
                    System.out.print(board[i][j]);
                }
                System.out.println();
            }*/

        
        char[][] newBoard = new char[boardLen][boardLen];

        if(fillPuzzleHelper(board, newBoard, 0, 0, dictionary)==false) {

            return null; //No solution found
        }

        return newBoard;

    }

    /*
     * Helper method for fillPuzzle.
     * board is the original board, newBoard is an 2d char array of the same size with the squares all filled in
     * row and col are used to determine where you are in the board
     * returns true if a solution is found, false if a solution is not found
     */

    private boolean fillPuzzleHelper(char[][] board, char[][] newBoard, int row, int col, DictInterface dictionary) {

        //The board is filled, can return
        if(row==board.length) {
            return true;
        }

        //Determine what the next square is
        int nextRow = row;
        int nextCol = col;
        if(col==board.length-1) {
            nextCol = 0;
            nextRow = row+1;
        }
        else {
            nextCol = col+1;
        }

        //Determine what the prev square is
        //Used for deleting last char on a stringbuilder if backtracking
        int prevRow = row;
        int prevCol = col;
        if(col==0) {
            if(row!=0) prevRow = row-1;
            prevCol = board.length-1;
        }
        else {
            prevCol = col-1;
        }

        //Printing out board (used for debugging)
        /*for(int i=0; i<newBoard.length; i++) {
            for(int j=0; j<newBoard.length; j++) {
                    System.out.print(newBoard[i][j]);
            }
            System.out.println();
        }*/

        if(board[row][col]=='+') { //Any valid letter can be placed here
            
                for(char c:letters) { //Cycle through all possible letters        

                if(isValid(board, newBoard, row, col, c, dictionary)) {

                    newBoard[row][col] = c; //Valid letter. Append to new board
                    if(fillPuzzleHelper(board, newBoard, nextRow, nextCol, dictionary)==true) { //Advance with next square
                        return true;
                    }
                
                }
                //Delete insertion
                else { //Invalid letter

                    //Reset newBoard back to no letter placed
                    //And delete last character of string builders
                    newBoard[row][col] = board[row][col];
                    rowStr[row].deleteCharAt(rowStr[row].length()-1);
                    colStr[col].deleteCharAt(colStr[col].length()-1);

                }

            }
        }

        else if(board[row][col]=='-') { //No letter may go here

            //Append to new board
            newBoard[row][col] = '-';
            
            //Determine where the last - is (used in isValid())
            rowLastMin[row] = col;
            rowLastMin[col] = row;

            if(fillPuzzleHelper(board, newBoard, nextRow, nextCol, dictionary)==true) { //Continue
                return true;
            }
            else { //Invalid placement

                //Reset newBoard back to -
                //And delete last character of string builders
                newBoard[row][col] = board[row][col];
                if(rowStr[row].length()>0) rowStr[row].deleteCharAt(rowStr[row].length()-1);
                if(colStr[col].length()>0) colStr[col].deleteCharAt(colStr[col].length()-1);
            }

        }

        else if(board[row][col]>=65 && board[row][col]<=122) { //There is already a letter in the square
                                //65 and 122 represent ASCII numbers to check if the square has a letter

            char c = board[row][col]; //automatically add letter to square

            if(isValid(board, newBoard, row, col, c, dictionary)) {

                newBoard[row][col] = c;
                if(fillPuzzleHelper(board, newBoard, nextRow, nextCol, dictionary)==true) { //continue
                    return true;
                }
                
             }
             else { //invalid

                //Reset newBoard back to whatever letter was predetermined
                //And delete last character of string builders
                newBoard[row][col] = board[row][col];
                rowStr[row].deleteCharAt(rowStr[row].length()-1);
                colStr[col].deleteCharAt(colStr[col].length()-1);
             }

        }

        else { //Number

            
            int limit = (int)(board[row][col])-48; //Determine the limit number as specified in board

            for(char c:letters) {

                //Check the amount of times letter has already been placed
                int timesPlaced = 0;
                for(int i=0; i<boardLen; i++) {
                    for(int j=0; j<boardLen; j++) {
                        if(newBoard[i][j]==c) {
                            timesPlaced++;
                        }
                    }
                }
                //System.out.println(timesPlaced);

                if(timesPlaced<limit) { //If char has not exceeded limit, check for valid placment
                    if(isValid(board, newBoard, row, col, c, dictionary)) {
                        newBoard[row][col] = c; //valid placement
                        if(fillPuzzleHelper(board, newBoard, nextRow, nextCol, dictionary)==true) { 
                            return true;
                        }
                
                    }
                    else { //invalid placement

                        //Reset newBoard back to number
                        //And delete last character of string builders
                        newBoard[row][col] = board[row][col];
                        rowStr[row].deleteCharAt(rowStr[row].length()-1);
                        colStr[col].deleteCharAt(colStr[col].length()-1);
                    }  
                }

            }

        }

        //Going back a square, delete end of row/col strings
        if(rowStr[prevRow].length()>0) rowStr[prevRow].deleteCharAt(rowStr[prevRow].length()-1);
        if(colStr[prevCol].length()>0) colStr[prevCol].deleteCharAt(colStr[prevCol].length()-1);

        return false; //no valid letter found.
                      //This starts backtracking, as it returns to the previous square as a result of recursive calls.

    }

    /*
     * Checks if a passed in char is a valid placement given the current state of the board.
     * Return true if valid placement, false if invalid.
     */
    
    private boolean isValid(char[][] board, char[][] newBoard, int row, int col, char c, DictInterface dictionary) {

        //rowNum and colNum are used to determine whether a word is a word, prefix, or both.
        int rowNum = -1;
        int colNum = -1;

        //To determine where we are in the board. IF edge or bottom, they need to be words.
        boolean edge = false;
        boolean bottom = false;

        if(row==boardLen-1 && col==boardLen-1) { //at last square on board
            edge = true;
            bottom = true;
        }
        else if(row==boardLen-1 || row==colLastMin[col]-1) { //at bottom of board or next square is a -
            bottom = true;
        }
        else if(col==boardLen-1 || col==rowLastMin[row]-1) { //at edge of board or next square is a -
            edge = true;
        }

        //Determine if current row, cols are words/prefixes
        rowNum = dictionary.searchPrefix(rowStr[row].append(c));
        colNum = dictionary.searchPrefix(colStr[col].append(c));

        if(edge && bottom) { //Both need to be words

            if((rowNum==2 && colNum==2) || (rowNum==2 && colNum==3) || 
                (rowNum==3 && colNum==2) || (rowNum==3 && colNum==3)) { //Both are valid words
                    return true;
            }
            else return false;

        }

        else if(edge) { //End of row, row word col prefix

            if((rowNum==2 || rowNum==3) && (colNum==1 || colNum == 3)) { //row is valid word col valid prefix
                return true;
            }
            else return false;

        }

        else if(bottom) { //End of col, col word row prefix

            if((rowNum==1 || rowNum==3) && (colNum==2 ||colNum==3)) { //col is valid word row valid prefix
                return true;
            }
            else return false;

        }

        else { //not end of row or col, both prefix

            if((rowNum==1 && colNum==1) || (rowNum==1 && colNum==3) || 
                (rowNum==3 && colNum==1) || (rowNum==3 && colNum==3)) { //both row and col are valid prefixes
                    return true;

            }
            else return false;

        }


    }
    
    /*
     * Check if filledBoard is a correct filling for a given empty board
     * 
     * @param emptyBoard is a 2-d array representing an empty board
     * @param filledBoard is a 2-d array representing a filled out board
     * @param dictionary is the dictinary to be used for checking the filled out board
     * @return true if rules defined in fillPuzzle has been followed and 
     *  every row and column is a valid word in the dictionary. If a row
     *  or a column includes one or more '-', then each segment should be 
     *  a valid word in the dictionary; the method returns false otherwise
     */
    public boolean checkPuzzle(char[][] emptyBoard, char[][] filledBoard, DictInterface dictionary) {

        //Create new StringBuilders and instantiate them
        StringBuilder[] checkRowStr = new StringBuilder[emptyBoard.length];
        StringBuilder[] checkColStr = new StringBuilder[emptyBoard.length];

        for(int i=0; i<emptyBoard.length; i++) {
            checkRowStr[i] = new StringBuilder();
            checkColStr[i] = new StringBuilder();
        }

        int checkBoardLen = filledBoard.length; //created for convience so I don't have to call .length every time

        //Determines if there is a - in the row or columns
        //Value = index of where - is, or -1 if there is none in the row/col.
        int[] checkRowLastMin = new int[checkBoardLen];
        int[] checkColLastMin = new int[checkBoardLen];
        for(int i=0; i<checkBoardLen; i++) {
            checkRowLastMin[i] = -1;
            checkColLastMin[i] = -1;
        }
        for(int i=0; i<checkBoardLen; i++) {
            for(int j=0; j<checkBoardLen; j++) {
                if(emptyBoard[i][j]=='-') {
                    checkRowLastMin[i] = j;
                    checkColLastMin[j] = i;
                }
            }
        }

        /*for(int i=0; i<checkBoardLen; i++) {
            System.out.print(checkRowLastMin[i] + " ");
            System.out.print(checkColLastMin[i] + " ");
        }*/

        boolean valid = false;

        for(int i=0; i<checkBoardLen; i++) {
            for(int j=0; j<checkBoardLen; j++) {

                if(emptyBoard[i][j]=='+' || (emptyBoard[i][j]>=65 && emptyBoard[i][j]<=122)) { //Board is empty or there is already a letter placed
                                                                //65 - 122 represent ASCII codes of letters
                    //Append to current string
                    checkRowStr[i].append(filledBoard[i][j]);
                    checkColStr[j].append(filledBoard[i][j]);
                    //System.out.println(i+" "+j+" "+checkRowStr[i]+" "+checkColStr[j]);
                }
                else if(emptyBoard[i][j]=='-') {
                    if(checkRowStr[i].length()>0 && j!=checkBoardLen-1) { //Hit a - but NOT at end of board

                        int rowNum = dictionary.searchPrefix(checkRowStr[i]);
                        if(rowNum==2 || rowNum==3) { //Current row string before - needs to be a word
                            valid = true;
                            checkRowStr[i].setLength(0); //reset String
                        }
                        else return false;

                    }   
                    if(checkColStr[j].length()>0 && i!=checkBoardLen-1) { //Hit a - but NOT at bottom of board

                        int colNum = dictionary.searchPrefix(checkColStr[j]);
                        if(colNum==2 || colNum==3) { //Current col string before - needs to be a word
                            valid = true;
                            checkColStr[j].setLength(0); //Reset String
                        }
                        else return false;


                    }
                }

                else if(emptyBoard[i][j]>=49 && emptyBoard[i][j]<=57) { //There is a number placed in board
                                                    //49 - 57 are ASCII values of number

                    //Add solution's spot to the current row and col strings                               
                    checkRowStr[i].append(filledBoard[i][j]);
                    checkColStr[j].append(filledBoard[i][j]);


                    //Variables to determine if limit has been reached
                    int limit = emptyBoard[i][j]-48; //-48 to change from ASCII to literal value
                    int timesPlaced = 0;
                    char c = filledBoard[i][j];

                    //Count how many times the letter has been placed
                    for(int n=0; n<checkBoardLen; n++) {
                        for(int m=0; m<checkBoardLen; m++) {

                            if(c==filledBoard[n][m]) {
                                timesPlaced++;
                            }

                        }
                    }

                    if(timesPlaced<=limit) { //The letter has not been placed too many times.
                        valid = true;
                    }
                    else return false; //Invalid, auto return false

                }

                if(j==checkBoardLen-1) { //At edge of board. Needs to be word

                    if(checkRowLastMin[i]==-1) { //No - in row

                        int rowNum = dictionary.searchPrefix(checkRowStr[i]);
                        if(rowNum==3 || rowNum==2) valid = true; //Row is a word
                        else return false; //Invalid, auto return false

                    }
                    else { //- In row

                        if(checkRowStr[i].length()>0) { //This needs to be checked because of reset of row/col strings after a -
                            int rowNum = dictionary.searchPrefix(checkRowStr[i]);
                            if(rowNum==3 || rowNum==2) valid = true;
                            else return false; //Invalid, auto return false
                        }
                        

                    }


                } 
                if(i==checkBoardLen-1) { //At bottom of board. Needs to be word

                    if(checkColLastMin[j]==-1) { //No - in col

                        int colNum = dictionary.searchPrefix(checkColStr[j]);
                        if(colNum==3 || colNum==2) valid = true; 
                        else return false; //Invalid, auto return false

                    }
                    else { //- in row

                        if(checkColStr[j].length()>0) { //This needs to be checked because of reset of row/col strings after a -

                            int colNum = dictionary.searchPrefix(checkColStr[j]);
                            if(colNum==3 || colNum==2) valid = true;
                            else return false; //Invalid, auto return false

                        }
                        

                    }

                }
                

            }
        }

        return valid;

    }

    public static void main(String[] args) {

        //System.out.print("Good grade please I tried :)");

    }


}
